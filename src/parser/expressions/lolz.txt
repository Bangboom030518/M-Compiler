map :: HashMap<number, (Expression, Vec<number>)>
LET map = terms MAPPED TO (EXPRESSION OF term, [INDEX OF term])

FOR operator IN operators {
    left_index = index LEFT OF operator
    right_index = index RIGHT OF operator

    LET (left_expr, left_indices) = map[left_index];
    LET (right_expr, right_indices) = map[right_index];
    LET expression = NEW BinaryExpression WHERE left = left, right = right

    UPDATE map {
        SET used_indeces = left_indices + right_indices;
        SET used_indeces IN map TO (expression, all_indicies_used)
    }
}

--------------

  0   2   1

0   1   2   3

1 / 1 + 2 / 1

--------------


Steps:

(b [2] c) as result -> a [1] result

0 -> 0, 2
1 -> 2, 4
2 -> 4, 6

   0    1
 0    1   2
(1 + (1 * 2))

   0    1    2
 0    1   2    3
(1 + (1 * 2) * 2)

SET 1, 2 => Expression

1 + (1 * (2 * 2))

0 => 0,1
1 => 1,2